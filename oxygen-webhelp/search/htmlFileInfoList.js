fil = new Array();
fil["0"]= "concepts/Aggregation.html@@@Aggregation@@@Epoch aggregation in a container is driven by the corresponding container service as a background job. The container service maintains one bit for each snapshot e i in the container metadata...";
fil["1"]= "concepts/Algorithmic_object_placement.html@@@Algorithmic object placement@@@DAOS-SR uses the pool map to create a set of placement maps that are used to compute algorithmic object layouts and to drive consensus data distribution. This approach uses consistent hash based...";
fil["2"]= "concepts/Architecture.html@@@Architecture@@@We consider a HPC cluster with hundreds of thousands of compute nodes interconnected via a scalable high-speed, low-latency fabric, where all or a subset of the nodes, called storage nodes, have...";
fil["3"]= "concepts/Authentication.html@@@Authentication@@@To connect to a pool, a process set must first be authenticated. To do so, we consider the following scenarios: The cluster is on a secure network that authenticates all incoming client connections...";
fil["4"]= "concepts/Authentication_Authorization.html@@@Authentication and Authorization@@@Unlike the private namespace, the system namespace is multi-tenant and is accessed by many different users and groups. The FUSE context will be used to identify the UID/GID of the requester which are...";
fil["5"]= "concepts/Authorization.html@@@Authorization@@@Access to a pool can be restricted to a set of users, groups or jobs with either full or limited capability. For instance, a given user can only access the pool in read-only mode. By default, all...";
fil["6"]= "concepts/Bulk_Sync_Checkpoint.html@@@Bulk Synchronous Checkpoint@@@Defensive I/O is used to manage a large simulation run over a period of time larger than the platform&apos;s mean time between failure (MTBF). The simulation regularly dumps the current computation state...";
fil["7"]= "concepts/Byte_Array.html@@@Byte Array@@@Because a fixed stripe byte-array object has constant stripe size and stripe count, data localities are computed from the data offset and the layout. For example, an offset divided by stripe size...";
fil["8"]= "concepts/Byte_Arrays.html@@@Byte Arrays@@@The second type of object supported by VOS is a byte-array object. Byte-array objects, similar to KV stores, allow multiple versions and must be able to write, read, and punch any part of the byte...";
fil["9"]= "concepts/Client_Interface.html@@@Client Interface@@@POSIX emulation will be provided through a client library, which will be built upon DAOS-SR. Any POSIX operation from the application will be intercepted, and forwarded to this DAOS POSIX(DSP)...";
fil["10"]= "concepts/Client_Library.html@@@Client Library@@@The DSM client library exports the DSM API, which includes methods to: connect to pools add or disable targets create or open containers do object I/Os flush, discard, or commit epochs manage...";
fil["11"]= "concepts/Client_Server_Architecture.html@@@Client/Server Architecture@@@Figure: DAOS Software Architecture As represented in the Figure 1 above, each DAOS layer (except VOS, which is only present on the storage nodes) is composed of both a client-side and a server-side...";
fil["12"]= "concepts/Client_Server_Arcjitecture.html@@@Client/Server Architecture@@@Figure: DAOS Software Architecture As represented in the Figure 1 above, each DAOS layer (except VOS, which is only present on the storage nodes) is composed of both a client-side and a server-side...";
fil["13"]= "concepts/Client_Server_Protocol.html@@@Client/Server Protocol@@@The client/server protocol is specific to the private or system namespace. Each use-case will implement different mechanisms for concurrency control, and will thus ship different calls. The figure...";
fil["14"]= "concepts/Client_replication.html@@@Client replication@@@DAOS-SR can choose the minimum replication protocol, which is synchronous and fully in the client stack, to provide high concurrency and low latency I/O for the upper layer stacks. I/O requests...";
fil["15"]= "concepts/Concurrency_Control.html@@@Concurrency Control@@@While DAOS epochs can be used to support Atomicity, Consistency and Durability guarantees, the Isolation property is considered beyond the scope of the DAOS transaction model. No mechanism to detect...";
fil["16"]= "concepts/Concurrency_Control_POSIX_Compliance.html@@@Concurrency Control and POSIX Compliance@@@To serialize concurrent accesses to the same object, the DSP server needs to implement a locking strategy. Given that well-behaved applications rarely generate conflicting metadata operations and also...";
fil["17"]= "concepts/Concurrent_Producers.html@@@Concurrent Producers@@@In the previous section, we consider a producer and a consumer job concurrently reading and writing into the same container, but in disjoint objects. We now consider a workflow composed of concurrent...";
fil["18"]= "concepts/Consistency.html@@@Consistency@@@In order to achieve the goal described above, the DSR adopts a simple protocol: A DSR I/O request can complete only if underlying I/O requests against all RDG members succeeded. More particular, this...";
fil["19"]= "concepts/Container_Creation.html@@@Container Creation@@@Creating a container goes through the pool service. After receiving the POOL_CONTAINER_CREATE request, the pool service either selects an existing container service from the container service index or...";
fil["20"]= "concepts/Container_Handle.html@@@Container Handle@@@Access to a container is controlled by the container handle. To acquire a valid handle, an application process must open the container and pass the security checks (user/group permission, \u2026). The...";
fil["21"]= "concepts/Container_Handles.html@@@Container Handles@@@When a client process calls the container open method, it may specify: a container name in the pool, or a container UUID, or a container UUID and a container service address. How the client process...";
fil["22"]= "concepts/Container_Service.html@@@Container Service@@@The container service maintains container metadata, including: Epoch state . This mainly consists of the container HCE and the maximum aggregated epoch (section 7.8.5). Container handles . Each...";
fil["23"]= "concepts/Container_State.html@@@Container State@@@As shown in the figure below below, the state of a container evolves as a sequence of consistent snapshots. Each state transition is sequentially numbered by epoch. Figure: Epoch in a Container Epochs...";
fil["24"]= "concepts/CrossContainer_Transaction.html@@@Cross-Container Transaction@@@The DAOS transaction model supports atomic updates across different containers from the same pool. This covers all server nodes of the pool. Cross-container transactions are achieved by committing...";
fil["25"]= "concepts/DAOS_Client_Libraries.html@@@DAOS Client Libraries@@@DAOS provides a collection of client libraries (one per-layer) that implement the external API exported to application developers. The DAOS client libraries as well as the networking parts do not...";
fil["26"]= "concepts/DAOS_Common_Libraries.html@@@DAOS Common Libraries@@@Common functionality and infrastructure shared across all DAOS components are provided in external shared libraries. This includes the following features: Hash and checksum routines Event and event...";
fil["27"]= "concepts/DAOS_Container.html@@@DAOS Container@@@A container represents an object address space inside a pool. To access a container, an application must first connect to the pool and then open the container. If the application is authorized to...";
fil["28"]= "concepts/DAOS_Intro.html@@@Distributed Asynchronous Object Storage@@@Warning: DAOS is under heavy development. Use at your own risk. The Distributed Asynchronous Object Storage (DAOS) stack provides a new storage paradigm for Exascale computing and Big Data. DAOS is an...";
fil["29"]= "concepts/DAOS_Layering.html@@@DAOS Layering@@@The DAOS stack is organized in four different layers. Each layer provides a unique set of functionality based on the abstraction offered by the layer below. The layered architecture relies on a...";
fil["30"]= "concepts/DAOS_M.html@@@DAOS-M@@@The DAOS-M layer (DSM) builds the pool and container abstractions that offer target-local objects. DSM consists of three types of services and a client library, which together implement the DSM API...";
fil["31"]= "concepts/DAOS_Object.html@@@DAOS Object@@@DAOS supports three types of objects: A byte array is collection of extents. Each extent is addressed by a 64-bit offset. A byte array supports arbitrary extent read, write and punch. A key-value...";
fil["32"]= "concepts/DAOS_POSIX_Service.html@@@DAOS-POSIX Service@@@The DAOS-POSIX (DSP) service runs on the storage nodes and provides handlers for DSP functions shipped by the DSP clients. The DSP service threads communicate altogether to manage transactions...";
fil["33"]= "concepts/DAOS_Pool.html@@@DAOS Pool@@@A pool is a set of targets spread across different storage nodes over which data and metadata are distributed to achieve horizontal scalability, and replicated or erasure-coded to ensure durability...";
fil["34"]= "concepts/DAOS_SR.html@@@DAOS-SR@@@The DAOS-SR is the layer that provides object abstractions with horizontal scalability and resilience. A DAOS-SR objet is distributed to multiple targets and represented by DAOS-M objects on these...";
fil["35"]= "concepts/DAOS_Server_Server_Modules.html@@@DAOS Server and Server Modules@@@The DAOS server is a persistent service running on all the storage nodes. It manages incoming requests for all targets hosted on the storage node and provides a stackable modular interface to load...";
fil["36"]= "concepts/DAOS_Storage_Model.html@@@DAOS Storage Model@@@In this section, we describe the DAOS storage paradigm including its transaction, security and fault models...";
fil["37"]= "concepts/DAOS_Storage_Stack.html@@@DAOS Storage Stack@@@This section introduces the layered architecture of the storage stack...";
fil["38"]= "concepts/DAOS_Target.html@@@DAOS Target@@@A target is the basic unit of storage allocation and space management. It is associated with a reservation of persistent memory optionally combined with block-based storage for capacity. A target has...";
fil["39"]= "concepts/DAOS_mOS.html@@@DAOS and mOS@@@This section addresses the interaction between the DAOS stack and the multi-Operating System (mOS) environment. The application processes running on the light-weight kernel (LWK) will directly access...";
fil["40"]= "concepts/Data_Fence.html@@@Data Fence@@@If an application keeps writing to the object that is in rebuilding, and the writing throughput is equal to or higher than the rebuild throughput, then the rebuilding process needs a fence for data...";
fil["41"]= "concepts/Directories.html@@@Directories@@@A directory will be represented by a dynamically striped document KV object. The directory entry name is used as the distribution key and the inode attributes will be stored in different attribute...";
fil["42"]= "concepts/Discussions_Transaction_Model.html@@@Discussions on Transaction Model@@@Although NVML transactions provide guarantees for data consistency, that does not come without a price. NVML creates, persists and maintains undo logs to provide necessary guarantees for recovery on...";
fil["43"]= "concepts/Distributed_Caching.html@@@Distributed Caching@@@DSP servers will rely on a novel scalable mechanism to cache frequently accessed data structures like directory entries. The primary goal is to speed up path resolution when all compute node wants to...";
fil["44"]= "concepts/Document_KV_object.html@@@Document KV object@@@A Document KV (DKV) object is a striped KV store where each KV record of it is identified by two keys: a distribution key and an attribute key. These two keys have different functionalities for this...";
fil["45"]= "concepts/Document_Stores.html@@@Document Stores@@@In addition to Key-value and Byte-array object, VOS would also offer a document store. The primary motivation of this type of object is to facilitate co-location of custom object metadata and object...";
fil["46"]= "concepts/Doubling_Domains.html@@@Doubling Domains@@@As previously mentioned, the ring placement map can be aware of one type of domain. If the number of domains of this type in the DAOS pool is doubled while extending the DAOS pool, then ideally, half...";
fil["47"]= "concepts/Doubling_Targets_within_Domains.html@@@Doubling Targets within Domains@@@Another way of symmetrically extending a DAOS pool is by doubling the number of targets within each domain. The number of domains is still the same after doubling, but the hash distance between...";
fil["48"]= "concepts/Dynamically_Striped_Byte_Array.html@@@Dynamically Striped Byte Array@@@A dynamically-stripped byte array always starts from a single stripe, and it can grow and extend itself to more targets. While extending a dynamically-stripped byte array, its &quot;last extended offset&quot...";
fil["49"]= "concepts/Dynamically_Striped_Key_Value.html@@@Dynamically Striped Key Value@@@As described in the previous sub-section, there is no data movement while extending a byte-array object, however, this is different for dynamically striped KV object. A KV object should use consistent...";
fil["50"]= "concepts/Dynamically_Striped_Object.html@@@Dynamically Striped Object@@@A fixed stripe object always has the same number of stripes since it was created. In contrast, a dynamically stripped object could be created with a single stripe. It will increase its stripe count as...";
fil["51"]= "concepts/Epoch_Based_Operations.html@@@Epoch Based operations@@@Epochs provide a way for modifying VOS objects without destroying the history of updates/writes. Each update consumes memory and discarding unused history can help reclaim unused space. VOS provides...";
fil["52"]= "concepts/Epoch_Distribution.html@@@Epoch Distribution@@@To guarantee consistency, all DAOS operations resulting from the processing of a POSIX operation will be submitted with the same epoch number. Multiple concurrent POSIX operations may use the same...";
fil["53"]= "concepts/Epoch_Protocol.html@@@Epoch Protocol@@@The epoch protocol, which involves the client library and all the three types of services, implements the epoch model described in section 3.2. This subsection first describes epochs within a single...";
fil["54"]= "concepts/Erasure_Code.html@@@Erasure Code@@@In the case of replicating a whole object, the overhead would be 100% for each replica. This is unaffordable in some cases, so DAOS-SR also provides erasure code as another option of data protection...";
fil["55"]= "concepts/FUSE_Mountpoint.html@@@FUSE Mountpoint@@@A FUSE mount point can be registered to export the encapsulated POSIX file system. The FUSE methods to manage this mount point will be implemented by a system daemon linking with the DSP client...";
fil["56"]= "concepts/Failure_Detection.html@@@Failure Detection@@@Failure detection of DAOS relies on the RAS system, which should actively notify DAOS servers of the failure. As described in the sections &quot;Fault Detection and Diagnosis&quot; and &quot;Fault Isolation&quot;, all...";
fil["57"]= "concepts/Failure_Handling_Rebuild.html@@@Failure Handling and Rebuild@@@Although redundant object data may not be lost on target failure, the objects with shards that became inaccessible due to the failure must now operate in degraded mode. It is important to rebuild this...";
fil["58"]= "concepts/Failure_Sequence_Rebuild.html@@@Failure Sequence and Rebuild@@@Because members of an erasure coded RDG are all different, it is vital to track the mapping of RDG member to rebuild target correctly when the RDG member is made inaccessible by a failure. This must...";
fil["59"]= "concepts/Fault_Detection_Diagnosis.html@@@Fault Detection and Diagnosis@@@DAOS delegates authority for detection of storage node failure to an external RAS service, which delivers authoritative notifications. The RAS system (Reliability, Availability, and Serviceability) is...";
fil["60"]= "concepts/Fault_Handling.html@@@Fault Handling@@@For private namespace, if any server or clients fail during running, the application will fail. In other words, the user needs to restart the application, which will remount the file system and reopen...";
fil["61"]= "concepts/Fault_Isolation.html@@@Fault Isolation@@@Once the RAS system has notified the pool metadata service of a failure, the faulty node must be excluded from the pool map. This is done automatically and silently if the DAOS pool has enough...";
fil["62"]= "concepts/Fault_Model.html@@@Fault Model@@@DAOS relies on massively distributed storage with no requirements on the failover capabilities of the underlying storage. Each target is thus effectively treated as a single point of failure. DAOS...";
fil["63"]= "concepts/Fault_Recovery.html@@@Fault Recovery@@@Upon exclusion from the pool map, each target starts the resilvering process automatically to restore data redundancy. First, each target creates a list of local objects impacted by the target...";
fil["64"]= "concepts/Fault_Tolerance.html@@@Fault Tolerance@@@Since the ring placement map ensures targets in the same fault domain are widely spaced, then provided there are enough fault domains, the ring map will not place object shards in the same redundancy...";
fil["65"]= "concepts/Feature_Overview_Limitations.html@@@Feature Overview and Limitations@@@SR byte-array objects with specific target affinity can be mapped directly in the application process address space. This feature is supported only for processes that are collocated with the target...";
fil["66"]= "concepts/Files.html@@@Files@@@The content of a regular file that grows beyond the first data block (stored along with the other inode attributes) is stored in a DAOS-SR dynamic byte-array object. Reads and writes to POSIX files...";
fil["67"]= "concepts/Fixed_Stripe_Object.html@@@Fixed Stripe Object@@@A fixed stripe object has a constant number of stripes and each stripe has a fixed stripe size, which is either the stripe size in bytes for an array object or the key range for a KV. Upper levels...";
fil["68"]= "concepts/Global_rebuild_status.html@@@Global rebuild status@@@When the Raft leader receives a failure notification from the RAS system, it should update the pool map for the failure, and collectively broadcast a rebuild request, which carries the pool map change...";
fil["69"]= "concepts/Hierarchical_Fault_Domains.html@@@Hierachical Fault Domains@@@A fault domain is a set of servers sharing the same point of failure and which are thus likely to fail altogether. DAOS assumes that fault domains are hierarchical and do no overlap. The actual...";
fil["70"]= "concepts/IO_Ordering_Flushing.html@@@I/O Ordering and Flushing@@@Prior to epoch commit, all I/O operations submitted by a process group against the to-be-committed epoch must be flushed. This assures that all caches are properly drained and updates are stored...";
fil["71"]= "concepts/Inmemory_Storage.html@@@In-Memory Storage@@@The VOS is designed to use a persistent-memory storage model that takes advantage of byte-granular, sub-\u00B5second storage access possible with new NVRAM technology. This enables a disruptive change in...";
fil["72"]= "concepts/Int_System_Management.html@@@Integration with System Management@@@The DAOS servers embed a storage manager module that can be used by the resource manager to allocate and initialize the storage backend to create storage target. The storage management API is...";
fil["73"]= "concepts/Inter_Container_Epochs.html@@@Inter-Container Epochs@@@When a client process needs to commit multiple epochs belonging to different containers atomically, it shall complete the write operations for all these epochs and flush them successfully before...";
fil["74"]= "concepts/Internal_Data_Structures.html@@@Internal Data Structures@@@Designing a VOS KV store requires a tree data structure that can grow dynamically and re-main self-balanced. The tree needs to be balanced to ensure that time complexity does not increase with...";
fil["75"]= "concepts/Intra_Container_Epochs.html@@@Intra-Container Epochs@@@The epochs of a container are managed by the matching container service. The container service maintains the definitive epoch state as part of the container metadata, whereas the target services have...";
fil["76"]= "concepts/Introduction.html@@@Introduction@@@The emergence of data-intensive applications in business, government, and academia is stretching existing I/O models beyond its capabilities. Modern I/O workloads feature an increasing proportion of...";
fil["77"]= "concepts/Key_Value.html@@@Key Value@@@The KV object uses consistent hash key ranges to distribute keys to different redundancy groups. Keys and values are replicated to all members of each redundancy group. This makes it possible to...";
fil["78"]= "concepts/Key_Value_Stores.html@@@Key Value Stores@@@High performance simulations generating large quantities of data require indexing and analysis of data, to achieve good insight. Key Value (KV) stores can play a vital role in simplifying storage of...";
fil["79"]= "concepts/Key_in_VOS_KV_Stores.html@@@Key in VOS KV Stores@@@VOS KV supports key sizes from small keys to extremely large keys. To provide this level of flexibility VOS hashes the keys with an assumption that with a fast and consistent hash function one can get...";
fil["80"]= "concepts/Layout_for_Index_Tables.html@@@Layout for Index Tables@@@Figure: Code Block representing the layout of container index table structures with NVML pointers and ListsCode Block representing the layout of container index table structures with NVML pointers and...";
fil["81"]= "concepts/Lilbsysio.html@@@Lilbsysio@@@Libsysio is an open source library providing POSIX-like file I/O and namespace support from the application program address space. Similarly to the VFS, libsysio intercepts a POSIX request, then...";
fil["82"]= "concepts/Load_Balancing_for_Failure.html@@@Load Balancing for Failure@@@When there is no failure, the ring placement map can evenly distribute objects to all targets. However, when there is a failure, the missing object shards should be rebuilt on surviving spare targets...";
fil["83"]= "concepts/Ltweight_IOStack_NVM_Lib.html@@@Lightweight I/O Stack: NVM Library@@@NVML is an open source collection of libraries for using persistent memory, optimized specifically for NVRAM. NVML is actually a collection of six libraries among which the libpmemobj library...";
fil["84"]= "concepts/Memory_Map_Support.html@@@Memory-Map Support@@@DAOS-SR also provides direct memory-map access to byte-array objects with target affinity...";
fil["85"]= "concepts/Merc_Function_Shipper.html@@@Mercury Function Shipper@@@Mercury is a user-space communication library designed for HPC systems. It provides an asynchronous RPC framework that abstracts a native fabric interface through a Network Abstraction Layer (NAL)...";
fil["86"]= "concepts/Metadata_Overhead.html@@@Metadata Overhead@@@VOS has many internal data structure making the amount of metadata to maintain object an important factor. Although it would be challenging to provide the exact amount of metadata associated with...";
fil["87"]= "concepts/MultiRing_Placement_Map.html@@@Multi-Ring Placement Map@@@As described earlier, although the single ring placement map consumes less memory, it has a few significant drawbacks: It can only be built from a DAOS pool that has exactly the same number of targets...";
fil["88"]= "concepts/Multi_Failure.html@@@Multi-Failure@@@In a large-scale storage cluster, multiple failures might occur when a rebuild from a previous failure is still in progress. In this case, DAOS-SR should neither simultaneously handle these failures...";
fil["89"]= "concepts/Multilayer_Function_Shipping.html@@@Multi-layer Function Shipping@@@Mercury provides a flexible plugin interface that allows shipping any function from a client to any remote storage server. DAOS will rely on this mechanism to allow any layer in the stack to execute...";
fil["90"]= "concepts/Namespace_Concurrency_Control.html@@@Concurrency Control@@@Unlike the private namespace, the system namespace handles requests from un-coordinated clients, which are not considered as &quot;well-behaved&quot; and could potentially generate contended POSIX operations...";
fil["91"]= "concepts/Namespace_Fault_Handling.html@@@Fault Handling@@@The system namespace supports a fault model similar to NFS in async mode, or a local file system. This means that, when a DSP server fails, the container storing the system namespace is rolled back to...";
fil["92"]= "concepts/Network_Transport.html@@@Network Transport@@@DAOS relies on a lightweight user-space communication stack based on function shipping, described in the following sections...";
fil["93"]= "concepts/No_Multi_Rebalance.html@@@No Multi-Rebalance@@@To simplify the design, multi-rebalance is not supported in this design. The user has to serialize pool-map extending operations...";
fil["94"]= "concepts/Node_Addressing.html@@@Node Addressing@@@Nodes within a Mercury process group are addressed by endpoints that are assigned for the lifetime of the session. DAOS, on the other hand, must store persistent node identifiers in the pool map...";
fil["95"]= "concepts/Object_Listing.html@@@Object Listing@@@VOS provides a way to list all non-empty objects IDs in a container. The object ID (see Section 3.1.3) consists of 192 bits of which bits 8 - 16 identify the type of object. This can allow enumeration...";
fil["96"]= "concepts/Object_Schema_object_class.html@@@Object Schema and object class@@@The DAOS object schema describes the definitions for object types, data protection methods, and data distribution strategies. Based on these definitions and the requirements, upper layer stacks of...";
fil["97"]= "concepts/Object_Shard_Index_Table.html@@@Object Shard Index Table (OSIT)@@@At the VOS level, each container shard has an Object Shard Index Table (OSIT) to index all object shards within this target. In addition to the interfaces to update/search object shard by ID, this...";
fil["98"]= "concepts/Object_Shard_Index_Table_Rebuild_Log.html@@@Object Shard Index Table and Rebuild Log@@@Although there is no persistently stored global rebuild status, each rebuild target has a persistent rebuild log. In the PULL model, the rebuild log of a target stores IDs and metadata of all objects...";
fil["99"]= "concepts/Online_Rebuild.html@@@Online Rebuild@@@When the Raft leader broadcasts the rebuild request and pool map change to other targets, some of those targets might learn about this information earlier than other targets. In addition, a client can...";
fil["100"]= "concepts/Online_rebalance.html@@@Online rebalance@@@If there is no concurrent I/O, as previously described, the rebalance protocol is quite like the rebuild. However, if there are concurrent I/Os, the protocol should have extra mechanism to guarantee...";
fil["101"]= "concepts/PMSchema_Compatibility.html@@@PM Schema Compatibility and Upgrade@@@The schema of persistent data structures might evolve from time to time to fix bugs, add new optimizations or support new features. To that end, VOS supports schema versioning. Upgrading the schema...";
fil["102"]= "concepts/POSIX_Client_Server_Architecture.html@@@Posix Client/Server Architecture@@@The DAOS-POSIX software framework provides the infrastructure to implement POSIX namespace encapsulation with different a locking and transaction strategy. It relies on a client/server architecture...";
fil["103"]= "concepts/POSIX_Emulation.html@@@POSIX Emulation@@@This section covers the internals of the POSIX namespace encapsulation inside a DAOS container. It first addresses generic considerations related to POSIX emulation over DAOS and then focuses on the...";
fil["104"]= "concepts/POSIX_Representation.html@@@POSIX Representation@@@This section describes the layout of the POSIX namespace over DAOS objects...";
fil["105"]= "concepts/Persistent_Memory_Based_Storage.html@@@Persistent Memory based Storage@@@...";
fil["106"]= "concepts/Placement_Map.html@@@Placement Map@@@A placement map essentially is an abstracted and permutated pool map; it does not necessarily include all details of the pool map. Instead it only retains component relationships that can be used to...";
fil["107"]= "concepts/Pool_Connections.html@@@Pool Connections@@@To establish a pool connection, a client process calls the pool connect method in the client library with the pool UUID, the pool service address, and the requested capabilities. The client library...";
fil["108"]= "concepts/Pool_Creation.html@@@Pool Creation@@@Because creating a pool requires special privileges for steps related to storage allocation and fault domain querying, it is handled by the storage management module, as described in sections 4.2.4...";
fil["109"]= "concepts/Pool_Map.html@@@Pool Map@@@A pool map is the detailed description of a DAOS storage pool. It contains the status and characteristics of storage components, and relationships between components to represent hierarchical...";
fil["110"]= "concepts/Pool_Service.html@@@Pool Service@@@A pool service maintains pool metadata, including: Pool connections . Each pool connection is represented by a pool handle identified by a client-generated handle UUID. See POOL_CONNECT below. The...";
fil["111"]= "concepts/Private_POSIX_Namespace.html@@@Private POSIX Namespace@@@The private POSIX Namespace is intended for applications collaborating in an HPC workflow, and is designed for scalability and performance on the assumption that conflicting operations - e.g. create...";
fil["112"]= "concepts/Producer_Consumer.html@@@Producer/Consumer@@@In Figure 1 , we have two examples of producer/consumer. The down-sample job consumes raw timesteps generated by the simulation job and produces sampled timesteps analysed by the post-process job. The...";
fil["113"]= "concepts/Protocol_Compatibility.html@@@Protocol Compatibility@@@Limited protocol interoperability is to be provided by the DAOS storage stack. Version compatibility checks will be performed to verify that: All targets in the same pool run the same protocol...";
fil["114"]= "concepts/Pvt_POSIXClient_Server_Protocol.html@@@Client/Server Protocol@@@This section describes the private namespace protocol. A DSP client sends POSIX requests to the DSP server in charge of the directory entry and inode attributes. The server handles these requests...";
fil["115"]= "concepts/RPC_Handling.html@@@RPC Handling@@@When an RPC request arrives at the leader, a service thread of the service module picks up the request and handles it by executing a handler function designed for this type of request. As far as...";
fil["116"]= "concepts/Read_Only_Mapping.html@@@Read-Only Mapping@@@A read-only mapping offers direct load access to a snapshot of a local DAOS byte-array object. This involves mapping the VOS extents associated with the object snapshot. To do so, portions of the...";
fil["117"]= "concepts/Rebalance.html@@@Rebalance@@@Rebalance is the process of redistributing objects while extending a DAOS pool. As described in the section Algorithmic object placement , different placement algorithms have different rebalancing...";
fil["118"]= "concepts/Rebalance_Protocol.html@@@Rebalance Protocol@@@Similarly with the rebuild protocol, rebalance of DAOS-SR relies on the RAS notification to discover the change of pool map, and relies on the Raft leader to propagate the change to other servers and...";
fil["119"]= "concepts/Rebalancing_Pool_Extension.html@@@Rebalancing for Pool Extension@@@When new storage targets are added to a DAOS pool, containers within this pool should rebalance data by migrating some of the existing object shards to the new targets. One of the major limits of the...";
fil["120"]= "concepts/Rebuild.html@@@Rebuild@@@When a target failed, the RAS system should promptly detect it and notify the Raft leader about the failure, the Raft leader can then collectively broadcast the failure event to all surviving targets...";
fil["121"]= "concepts/Rebuild_Declustering.html@@@Rebuild Declustering@@@In a multi-ring placement map, targets have different neighbors on the different rings. If one target fails, all neighbors on all rings can contribute to data rebuild, which can significantly reduce...";
fil["122"]= "concepts/Rebuild_Log.html@@@Rebuild Log@@@To generate the rebuild log, the DAOS-SR server needs to scan each record in an OSIT, and calculate the layout and determine the redundancy group (RDG) of the object shard. If the faulty target is a...";
fil["123"]= "concepts/Rebuild_Methods.html@@@Rebuild Methods@@@While reconstructing a missing object shard, the rebuild target (rebuild initiator), which owns the rebuild log for this object shard, can algorithmically determine the source targets (rebuild...";
fil["124"]= "concepts/Rebuild_Protocol.html@@@Rebuild Protocol@@@Previous sections have already introduced major components and mechanisms for rebuild. This section summarizes and describes the generic protocol of DSR rebuild. It focuses on the protocol for...";
fil["125"]= "concepts/Rebuild_Targets.html@@@Rebuild Targets@@@Rebuild targets are targets that will be used to reconstruct object shards that become inaccessible due to target failures. In the figure below, an object is distributed on targets-[3, 4, 5, 6] and...";
fil["126"]= "concepts/Rebuild_erasure_coded_object.html@@@Rebuild erasure coded object@@@In order to rebuild object protected by erasure code, the rebuild initiator should always pull data from multiple sources, because the missing object shard has to be reconstructed from multiple object...";
fil["127"]= "concepts/Rebuild_replicated_object.html@@@Rebuild replicated object@@@For objects protected by replication, although a missing replica can be rebuilt fully from any of the surviving replicas, however, pulling all data from a single replica could overload the target that...";
fil["128"]= "concepts/Replication.html@@@Replication@@@Replication ensures high availability of object data because objects are accessible while any replica exists. Replication can also increase read bandwidth by allowing concurrent reads from different...";
fil["129"]= "concepts/Ring_Placement_Map.html@@@Ring Placement Map@@@The first approach of building a placement is to place storage targets on a consistent hashing ring, called a ring placement map. Ring placement can handle one level of fault domain to avoid data loss...";
fil["130"]= "concepts/Root_Object.html@@@Root Object@@@The root object in NVML facilitates locating the superblock of a Versioning object store. The superblock is the starting point of accessing the versioning object store and contains information of the...";
fil["131"]= "concepts/SW_Compatibility.html@@@Software Compatibility@@@Interoperability in DAOS is handled via protocol and schema versioning for PM data structures...";
fil["132"]= "concepts/Scalable_Inode_Object_Allocation.html@@@Scalable Inode/Object Allocation@@@Inode number will be implemented by object ID. To make sure object ID is unique in the whole file system, a thread called object ID server (IDS), will be started to manage the object ID allocation...";
fil["133"]= "concepts/Scalable_OIT.html@@@Scalable Object Index Table (OIT)@@@The Object Index Table (OIT) is essentially a distributed KV object that plays a special role in DAOS-SR because most objects store their IDs and metadata within it. It is distributed on all targets...";
fil["134"]= "concepts/Security_Model.html@@@Security Model@@@A pool is only accessible to authenticated and authorized jobs. The security framework to be used must be selected and configured at pool-creation time. In the future, an additional authorization...";
fil["135"]= "concepts/Server_replication.html@@@Server replication@@@DAOS-SR could also support server replication, which has stronger consistency of replicas with a trade-off in performance and latency, for example, a primary-copy replication protocol. With a...";
fil["136"]= "concepts/Service_Management.html@@@Service Management@@@The pool service maintains a record of every container service in the container service index (section 7.2.1) and manages the configuration (i.e., the set of replicas) of every one of them, as well as...";
fil["137"]= "concepts/Service_Replication.html@@@Service Replication@@@Pool and container services are made highly available by replicating their state\u00E2\u20AC\u201Dpool and container metadata\u00E2\u20AC\u201Dusing Raft-based consensus and strong leadership. A service replicated in this generic...";
fil["138"]= "concepts/Services.html@@@Services@@@This subsection enumerates all three types of services, discussing the state each of them manages and the main RPCs each of them handles. An RPC procedure has the following format: PROCEDURE...";
fil["139"]= "concepts/Single_unstriped_Object.html@@@Single (unstriped) Object@@@Single (unstriped) objects always protect data by replication, they can generate the localities of replicas by the placement algorithm. For upper level that requires target affinity, instead of...";
fil["140"]= "concepts/Snapshots.html@@@Snapshots@@@The scope of a snapshot is an epoch of a container. The epoch must be equal to or higher than the handle LRE and be equal to or less than the handle HCE. A client taking a snapshot sends a...";
fil["141"]= "concepts/Store_Mgmnt_Wkflow_Int.html@@@Storage Management and Workflow Integration@@@In this section, we consider two different cluster configurations: Cluster A: All or a majority of the compute nodes have local persistent memory. In other words, each compute node is also a storage...";
fil["142"]= "concepts/Store_Node_Fail_Resilver.html@@@Storage Node Failure and Resilvering@@@In this section, we consider a workflow connected to a DAOS pool and one storage node that suddenly fails. Both DAOS clients and servers communicating with the failed server experience RPC timeouts...";
fil["143"]= "concepts/Superblock_Reserved_Objects.html@@@Superblock and Reserved Objects@@@A superblock recording file-system-wide information is stored in a document KV object with a pre-defined object identifier. The superblock is created when the container is initialized as a POSIX file...";
fil["144"]= "concepts/Supported_Key_Value_operations.html@@@Operations Supported with Key Value Stores@@@VOS supports large keys and values with four types of operations namely, update, lookup, punch, and key enumeration. The update and punch operations add a new key to a KV store or log a new value of...";
fil["145"]= "concepts/Svc_Repl_Architecture.html@@@Architecture@@@A replicated service is built around a Raft replicated log. The service transforms RPCs into state queries and deterministic state updates. All state updates are committed to the replicated log first...";
fil["146"]= "concepts/System_Namespace.html@@@System Namespace@@@A shared global namespace accessible from all the compute nodes is provided to store application binaries, libraries, user files, and links to other containers...";
fil["147"]= "concepts/Target_Faults.html@@@Target Faults@@@Given hundreds of thousands of targets, the epoch protocol must allow progress in the presence of target faults. Since pool and container services are highly available, the problem is mainly concerned...";
fil["148"]= "concepts/Target_Service.html@@@Target Service@@@The target service exports the VOS methods and abstracts the complexity of the underlying file system structures that store the persistent state of VOS and the target service itself. All object I/Os...";
fil["149"]= "concepts/Terminology.html@@@Terminology@@@Acronym Expansion DAOS Distributed Asynchronous Object Storage DAOS-M/DSM DAOS Persistent Memory Storage layer DAOS-SR/DSR DAOS Sharding and Resilience layer DAOS-P/DSP DAOS POSIX layer FWK...";
fil["150"]= "concepts/Transaction_Model.html@@@Transaction Model@@@The transaction model used by the private namespace is fairly simple. DSP servers use the same epoch number, which is committed on application demand (flush, sync or other API exported by DAOS) or...";
fil["151"]= "concepts/Transactional_Model.html@@@Transactional Model@@@The primary goal of the DAOS transaction model is to provide a high degree of concurrency and control over durability of the application data and metadata. Applications should be able to safely update...";
fil["152"]= "concepts/Transactions_Recovery.html@@@Transactions and Recovery@@@Transactions are required with persistent memory to ensure a consistent state at all times. The following code sample shows transaction flow with the different stages using macros. Figure: Transaction...";
fil["153"]= "concepts/Unrecoverable_Failure.html@@@Unrecoverable Failure@@@When there are multiple failures, if the number of failed targets from different domains exceeds the fault tolerance level of any schema within the container, then there could be unrecoverable errors...";
fil["154"]= "concepts/Update_Mapping_Redundancy_Support.html@@@Update Mapping and Redundancy Support@@@Similarly to read-only mapping, update mapping relies on a dedicated kernel driver to man-age the memory-map region. An mmap request for update will thus be handled as follows: Grab an hold on HCE+1...";
fil["155"]= "concepts/Use_Cases.html@@@Use Cases@@@This section provides a non-exhaustive list of use cases presenting how the DAOS storage model and stack could be used on a real HPC cluster...";
fil["156"]= "concepts/VOS_Aggregate.html@@@VOS Aggregate@@@During aggregation, VOS must retain only the latest update to a key/extent-range discarding the others. VOS looks up the lists of object ID from the epoch index table for the requested epoch range...";
fil["157"]= "concepts/VOS_Checksum_Management.html@@@VOS Checksum Management@@@One of the guarantees that VOS provides is end-to-end data integrity. Data corruption in VOS can happen while reading or writing data due to a various reasons, including leaks or failures in...";
fil["158"]= "concepts/VOS_Concepts.html@@@VOS Concepts@@@The versioning object store provides object storage local to a storage node by initializing a VOS pool (vpool) as one shard of a DAOS pool. A vpool can hold objects for multiple object address spaces...";
fil["159"]= "concepts/VOS_Discard.html@@@VOS Discard@@@Discard forcefully removes epochs without aggregation. Use of this operation is necessary only when value/extent-data associated with a {container handle cookie, epoch} pair needs to be discarded...";
fil["160"]= "concepts/VOS_Flush.html@@@VOS Flush@@@VOS also provides a flush operation that checks if all updates/writes and their data in a given epoch are durable in the underlying persistent memory. This operation leverages the NVML library API to...";
fil["161"]= "concepts/VOS_Indexes.html@@@VOS Indexes@@@Design of the object index and epoch index tables are similar to the container index table with the object ID and epoch number as keys respectively. The value of the object index table points to the...";
fil["162"]= "concepts/VOS_over_NVM_Library.html@@@VOS over NVM Library@@@VOS accesses persistent memory (pmem) with the help of the Non-volatile memory library (NVML) . A persistent-memory aware file system exposes persistent memory to the operating system. Unlike...";
fil["163"]= "concepts/Version_Obj_Store.html@@@Versioning Object Store@@@The Versioning Object Store (VOS) is responsible for providing and maintaining a persistent object store that supports byte-granular access and versioning. It maintains its own metadata in persistent...";
fil["164"]= "concepts/Widely_Striped_Object.html@@@Widely Striped Object@@@In the example in the previous figure , all 8 rings have 8 targets. An object cannot therefore have more than 8 shards, and applications cannot efficiently use the full bandwidth of the storage...";
fil["165"]= "concepts/Wkflow_Execution.html@@@Workflow Execution@@@We consider the workflow represented in the figure below. Figure: Example of a Scientific Workflow Each green box represents a different container. All containers are stored in the same DAOS pool...";
var doStem = false;searchLoaded = true;